{
    "COURSE_OUTLINE_PROMPT": "Generate a course outline based on the input files and instructions provided. The course outline should include the following sections:\nThe number of modules specified, the module name, the module description and each module should have the learning outcomes\nDo not have any text, just give me the course outline\nInput:\n- Instructions: Additional instructions for generating the course outline\n{INSTRUCTIONS}\nOutput:\n- Course Outline: The generated course outline with the specified sections and modules",
    "COURSE_OUTLINE_TO_MODULES_PROMPT": "You are given a course outline. \nYou have to convert it into modules in the following format:\nInstructions:\n1. Your output will be used as an input to python code. So make sure the output is in the correct format.\n2. Do not return anything else other than the modules.\n```\njson\n{{ \"modules\":[\n        {{\n    \"module_name\": \"Module name\",\n    \"module_description\": \"This module covers the basics of the course\",\n        }},\n        {{\n    \"module_name\": \"Module name\",\n    \"module_description\": \"This module covers the advanced topics of the course\",\n        }}\n    ]\n}}\n```\nInput:\n- Course Outline: The course outline with the specified sections and modules\n{COURSE_OUTLINE}\nOutput:\n- Modules: The modules generated from the course outline in the specified format",
    "GENERATE_STREAMLIT_CODE_PROMPT": "Based on the following technical requirements:\n \n ```\n {FORMAL_REQUIREMENTS}\n ```\n And referencing the following tech stack or repository:\n \n ```\n {TECH_STACK_INFO}\n ```\n Generate a Python-based Streamlit application page that performs the statistical analysis and visualizations specified below:\n ```\n {ANALYSIS_AND_VISUALIZATIONS}\n ```\n **Learning Outcomes**\n - This application should clearly display the following learning outcomes on the frontend:\n \n ```\n {LEARNING_OUTCOMES}\n ```\n - Include an introductory section in the UI that explains these learning outcomes to the user and clarifies how each component of the application aligns with them. Each analytical or visualization section should, where relevant, reference the corresponding learning outcome.\n This will be a standalone, single-page application embedded within a larger Streamlit container app. It should integrate seamlessly with other pages in the container without relying on global configurations like `st.set_page_config()`. Follow these essential guidelines:\n \n **1. Code Modularity and Structure**\n - Structure the code modularly, separating each major operation (e.g., data loading, preprocessing, and plotting) into distinct functions.\n - Use clear and descriptive function names (e.g., `load_data()`, `perform_analysis()`, `generate_plot()`) to describe each analytical or visualization task.\n - Ensure the application has a single entry point, defined in a `main()` function. The entire code should be contained within this `main()` function, which will act as the primary execution point.\n - Avoid setting global configurations such as `st.set_page_config()` since this page is part of a multi-page container application.\n \n **2. Interactivity and User Experience**\n - The application should be highly interactive, using Streamlit widgets (e.g., `st.slider`, `st.selectbox`, `st.checkbox`, `st.text_input`) to allow users to control data inputs, adjust visualization parameters, filter data, and select analysis options.\n - Clearly explain each component’s purpose and interactivity to the user, with instructions presented in the UI. Include tooltips, placeholder texts, and context-sensitive descriptions to guide users on how to use each widget effectively.\n - Ensure the UI follows a logical workflow that guides the user from initial data selection through analysis and interpretation of results.\n \n **3. Analytical and Visualization Requirements**\n - The application should perform all statistical analyses and visualizations as specified in `{ANALYSIS_AND_VISUALIZATIONS}`, with user-adjustable parameters for flexible exploration.\n - Each visualization should be customizable through user inputs, allowing adjustments like axis labels, histogram bin sizes, color schemes, date ranges, etc.\n - Display statistical summaries or key metrics alongside visualizations, such as regression summaries or descriptive statistics, where relevant.\n - Use Streamlit’s chart components (`st.line_chart`, `st.bar_chart`, `st.pyplot`) and make sure all visual outputs update responsively based on user interactions.\n \n **4. Documentation and Code Clarity**\n - Write clear docstrings for each function, describing its purpose, input parameters, and return values.\n - Provide inline comments to clarify complex or non-intuitive sections of the code, ensuring readability for future developers.\n - Structure the code so that default values and configurations are easily replaceable or adaptable.\n \n **5. Flexibility and Extensibility**\n - Design the page so it can be independently maintained, without reliance on external states or global variables.\n - Parameterize hardcoded values (e.g., column names, file paths) where possible, to enable easy adaptation.\n - Design for compatibility with a multi-page app, avoiding dependencies on app-wide configurations.\n \n **Additional Considerations**\n - Add loading indicators (e.g., `st.spinner`) during data processing to improve user experience.\n - Implement error handling for missing data, incompatible types, or invalid inputs with user-friendly error messages.\n - Use `st.cache_data` to optimize performance for repetitive data loading or processing tasks.\n \n **Instructions and User-Facing Descriptions**\n - Provide clear instructions in the UI on using each part of the app. Add tooltips or placeholder texts to guide users on interacting with widgets.\n - Explain how each part of the application contributes to achieving the specified learning outcomes, connecting analytical or visualization components with the learning objectives.\n \n Only return the Streamlit code as a single string, with `import streamlit as st` as the first line and ending with the definition of `def main()`. This `main()` function will serve as the entry point for the application.",
    "REPORT_GENERATION_PROMPT": "You are a report generation assistant tasked with producing a well-formatted context given parsed context.\nYou will be given context from one or more reports that take the form of parsed text.\nYou are responsible for producing a report with interleaving text and images - in the format of interleaving text and \"image\" blocks.\nSince you cannot directly produce an image, the image block takes in a file path - you should write in the file path of the image instead.\nHow do you know which image to generate? Each context chunk will contain metadata including an image render of the source chunk, given as a file path. \nInclude ONLY the images from the chunks that have heavy visual elements (you can get a hint of this if the parsed text contains a lot of tables).\nYou MUST include at least one image block in the output.\nYou MUST output your response as a tool call in order to adhere to the required output format. Do NOT give back normal text.",
    "LECTURE_OUTLINE_PROMPT": "Generate a lecture outline based on the input files and the instructions provided. The lecture outline should the slide information for each slide that it the lecture will contain. \nInput: \n- Instructions: Additional instructions for generating the lecture outline\n{INSTRUCTIONS}\nOutput: \n- Lecture Outline: The generated lecture outline with the specified sections and slides"
}